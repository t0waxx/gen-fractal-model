<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D フラクタルジェネレーター - 多角形対応・自動回転・パネル表示切替・光源調整</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; }
        #canvasContainer { width: 100%; height: 100%; }
        .slider-value { min-width: 3.5em; text-align: right; display: inline-block; } /* Adjusted min-width for float values */
        /* Custom modal styles */
        .modal {
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Ensure modal is above other content */
        }
        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            text-align: center;
        }
        .modal-button {
            padding: 8px 16px;
            margin-top: 15px;
            background-color: #3b82f6; /* Tailwind blue-500 */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .modal-button:hover {
            background-color: #2563eb; /* Tailwind blue-600 */
        }
        .top-buttons-container {
            position: fixed;
            top: 1rem; /* 16px */
            left: 1rem; /* 16px */
            z-index: 50;
            display: flex;
            gap: 0.5rem; /* 8px */
        }
        /* Ensure sliders are consistently styled */
        input[type="range"].accent-blue-500::-webkit-slider-thumb { background-color: #3b82f6; }
        input[type="range"].accent-blue-500::-moz-range-thumb { background-color: #3b82f6; }
        input[type="range"].accent-teal-500::-webkit-slider-thumb { background-color: #14b8a6; }
        input[type="range"].accent-teal-500::-moz-range-thumb { background-color: #14b8a6; }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col md:flex-row h-screen">

    <div class="top-buttons-container">
        <button id="toggleControlsButton" title="コントロールパネルの表示切替" class="bg-blue-600 hover:bg-blue-700 text-white font-bold p-2 rounded-lg shadow-md transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
            <svg id="iconClosePanel" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
            </svg>
            <svg id="iconOpenPanel" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16" />
            </svg>
        </button>

        <button id="autoRotateToggleButton" title="自動回転の切替" class="bg-teal-500 hover:bg-teal-600 text-white font-bold p-2 rounded-lg shadow-md transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-teal-400 focus:ring-opacity-50">
            <svg id="iconRotateOn" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"> <path stroke-linecap="round" stroke-linejoin="round" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <svg id="iconRotateOff" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"> <path stroke-linecap="round" stroke-linejoin="round" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
        </button>
    </div>

    <div id="controls" class="w-full md:w-96 bg-gray-800 p-6 space-y-4 overflow-y-auto shadow-lg rounded-lg md:rounded-l-none md:rounded-r-lg m-2 md:m-0 md:mr-2">
        <h1 class="text-2xl font-bold text-center text-blue-400 mb-4">3D フラクタル設定</h1>
        
        <div>
            <label for="fractalTypeSelector" class="block text-sm font-medium text-gray-300">フラクタルタイプ:</label>
            <select id="fractalTypeSelector" class="w-full mt-1 block py-2 px-3 border border-gray-600 bg-gray-700 text-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                <option value="sierpinskiTetrahedron">シェルピンスキー四面体</option>
                <option value="mengerSponge">メンガースポンジ (立方体)</option>
                <option value="sierpinskiOctahedron">シェルピンスキー八面体</option>
            </select>
        </div>

        <div>
            <label for="levelSlider" class="block text-sm font-medium text-gray-300">再帰レベル: <span id="levelValue" class="slider-value font-semibold text-blue-300">3</span></label>
            <input type="range" id="levelSlider" min="0" max="10" value="3" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500 mt-1">
        </div>
        <div>
            <label for="sizeSlider" class="block text-sm font-medium text-gray-300">基本サイズ: <span id="sizeValue" class="slider-value font-semibold text-blue-300">5.0</span></label>
            <input type="range" id="sizeSlider" min="1" max="10" value="5" step="0.1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500 mt-1">
        </div>
        <div>
            <label for="colorPicker" class="block text-sm font-medium text-gray-300">フラクタル色:</label>
            <input type="color" id="colorPicker" value="#1E90FF" class="w-full h-10 p-1 bg-gray-700 border border-gray-600 rounded-lg cursor-pointer mt-1">
        </div>
        <button id="generateButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition duration-150 ease-in-out shadow-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
            生成
        </button>
        <button id="exportObjButton" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition duration-150 ease-in-out shadow-md focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50" disabled>
            OBJエクスポート
        </button>

        <div class="mt-6 pt-4 border-t border-gray-700 space-y-3">
            <h2 class="text-xl font-semibold text-center text-teal-400 mb-3">光源設定</h2>
            
            <div>
                <label for="ambientIntensitySlider" class="block text-sm font-medium text-gray-300">環境光 強度: <span id="ambientIntensityValue" class="slider-value font-semibold text-teal-300">0.8</span></label>
                <input type="range" id="ambientIntensitySlider" min="0" max="3" value="0.8" step="0.1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-teal-500 mt-1">
            </div>
            
            <div>
                <label for="directionalIntensitySlider" class="block text-sm font-medium text-gray-300">指向性光 強度: <span id="directionalIntensityValue" class="slider-value font-semibold text-teal-300">1.2</span></label>
                <input type="range" id="directionalIntensitySlider" min="0" max="5" value="1.2" step="0.1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-teal-500 mt-1">
            </div>
            
            <div>
                <label for="directionalLightXSlider" class="block text-sm font-medium text-gray-300">指向性光 X位置: <span id="directionalLightXValue" class="slider-value font-semibold text-teal-300">15</span></label>
                <input type="range" id="directionalLightXSlider" min="-50" max="50" value="15" step="1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-teal-500 mt-1">
            </div>
            
            <div>
                <label for="directionalLightYSlider" class="block text-sm font-medium text-gray-300">指向性光 Y位置: <span id="directionalLightYValue" class="slider-value font-semibold text-teal-300">25</span></label>
                <input type="range" id="directionalLightYSlider" min="-50" max="50" value="25" step="1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-teal-500 mt-1">
            </div>
            
            <div>
                <label for="directionalLightZSlider" class="block text-sm font-medium text-gray-300">指向性光 Z位置: <span id="directionalLightZValue" class="slider-value font-semibold text-teal-300">30</span></label>
                <input type="range" id="directionalLightZSlider" min="-50" max="50" value="30" step="1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-teal-500 mt-1">
            </div>

            <div>
                <label for="fillIntensitySlider" class="block text-sm font-medium text-gray-300">フィルライト 強度: <span id="fillIntensityValue" class="slider-value font-semibold text-teal-300">0.5</span></label>
                <input type="range" id="fillIntensitySlider" min="0" max="3" value="0.5" step="0.1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-teal-500 mt-1">
            </div>

            <div>
                <label for="hemisphereIntensitySlider" class="block text-sm font-medium text-gray-300">半球光 強度: <span id="hemisphereIntensityValue" class="slider-value font-semibold text-teal-300">0.7</span></label>
                <input type="range" id="hemisphereIntensitySlider" min="0" max="3" value="0.7" step="0.1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-teal-500 mt-1">
            </div>
        </div>


        <p class="text-xs text-gray-500 text-center mt-4">マウスで視点操作: 左ドラッグで回転、右ドラッグで平行移動、ホイールでズーム。自動回転ボタンがオフの場合、3秒間操作がないと自動回転します。</p>
        <p class="text-xs text-gray-600 text-center mt-2">注意: 高い再帰レベル (特にメンガースポンジや八面体) は、ブラウザおちるかも</p>
    </div>

    <div id="canvasContainer" class="flex-grow relative rounded-lg overflow-hidden m-2 md:m-0">
        <canvas id="fractalCanvas"></canvas>
        <div id="loadingIndicator" class="absolute inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center text-white text-xl z-20" style="display: none;">
            生成中...
        </div>
    </div>
    
    <div id="messageModal" class="modal" style="display: none;">
        <div class="modal-content bg-gray-800 text-white rounded-lg p-6 shadow-xl">
            <p id="modalMessageText" class="mb-4"></p>
            <button id="modalCloseButton" class="modal-button bg-blue-600 hover:bg-blue-700">OK</button>
        </div>
    </div>

    <script>
        let scene, camera, renderer, controls;
        let fractalMesh;
        let generatedVertices = []; 
        let generatedFaces = [];    

        // Light objects - made accessible for dynamic updates
        let ambientLight, directionalLight, fillLight, hemisphereLight;

        let inactivityTimeoutId = null;
        let isUserInteracting = false;
        let isAutoRotatingByInactivity = false;
        let isContinuousAutoRotateOn = false; 
        const AUTO_ROTATE_DELAY = 3000; 
        const AUTO_ROTATE_SPEED = 0.002; 

        // DOM Elements
        const canvas = document.getElementById('fractalCanvas');
        const canvasContainer = document.getElementById('canvasContainer');
        const fractalTypeSelector = document.getElementById('fractalTypeSelector');
        const levelSlider = document.getElementById('levelSlider');
        const sizeSlider = document.getElementById('sizeSlider');
        const colorPicker = document.getElementById('colorPicker');
        const levelValueDisplay = document.getElementById('levelValue');
        const sizeValueDisplay = document.getElementById('sizeValue');
        const generateButton = document.getElementById('generateButton');
        const exportObjButton = document.getElementById('exportObjButton');
        const loadingIndicator = document.getElementById('loadingIndicator');
        
        const messageModal = document.getElementById('messageModal');
        const modalMessageText = document.getElementById('modalMessageText');
        const modalCloseButton = document.getElementById('modalCloseButton');

        const toggleControlsButton = document.getElementById('toggleControlsButton');
        const controlsPanel = document.getElementById('controls');
        const iconOpenPanel = document.getElementById('iconOpenPanel'); 
        const iconClosePanel = document.getElementById('iconClosePanel'); 

        const autoRotateToggleButton = document.getElementById('autoRotateToggleButton');
        const iconRotateOn = document.getElementById('iconRotateOn'); 
        const iconRotateOff = document.getElementById('iconRotateOff');

        // Lighting control DOM elements
        const ambientIntensitySlider = document.getElementById('ambientIntensitySlider');
        const ambientIntensityValue = document.getElementById('ambientIntensityValue');
        const directionalIntensitySlider = document.getElementById('directionalIntensitySlider');
        const directionalIntensityValue = document.getElementById('directionalIntensityValue');
        const directionalLightXSlider = document.getElementById('directionalLightXSlider');
        const directionalLightXValue = document.getElementById('directionalLightXValue');
        const directionalLightYSlider = document.getElementById('directionalLightYSlider');
        const directionalLightYValue = document.getElementById('directionalLightYValue');
        const directionalLightZSlider = document.getElementById('directionalLightZSlider');
        const directionalLightZValue = document.getElementById('directionalLightZValue');
        const fillIntensitySlider = document.getElementById('fillIntensitySlider');
        const fillIntensityValue = document.getElementById('fillIntensityValue');
        const hemisphereIntensitySlider = document.getElementById('hemisphereIntensitySlider');
        const hemisphereIntensityValue = document.getElementById('hemisphereIntensityValue');


        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    func.apply(context, args);
                }, delay);
            };
        }

        function showMessage(message) {
            modalMessageText.textContent = message;
            messageModal.style.display = 'flex';
        }

        modalCloseButton.addEventListener('click', () => {
            messageModal.style.display = 'none';
        });
        
        function handleInteractionStart() {
            isUserInteracting = true;
            isAutoRotatingByInactivity = false; 
            clearTimeout(inactivityTimeoutId); 
        }

        function handleInteractionEnd() {
            isUserInteracting = false;
            if (!isContinuousAutoRotateOn) {
                resetInactivityTimer();
            }
        }
        
        function resetInactivityTimer() {
            if (isContinuousAutoRotateOn || isUserInteracting) {
                clearTimeout(inactivityTimeoutId);
                isAutoRotatingByInactivity = false;
                return;
            }
            
            clearTimeout(inactivityTimeoutId);
            isAutoRotatingByInactivity = false; 
            inactivityTimeoutId = setTimeout(() => {
                if (!isUserInteracting && !isContinuousAutoRotateOn) {
                    isAutoRotatingByInactivity = true;
                }
            }, AUTO_ROTATE_DELAY);
        }


        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827); // Dark gray background

            camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
            camera.position.set(0, 5, 18); 

            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 

            // Initialize lights using slider values
            ambientLight = new THREE.AmbientLight(0xffffff, parseFloat(ambientIntensitySlider.value));
            scene.add(ambientLight);
            
            directionalLight = new THREE.DirectionalLight(0xffffff, parseFloat(directionalIntensitySlider.value));
            directionalLight.position.set(
                parseFloat(directionalLightXSlider.value), 
                parseFloat(directionalLightYSlider.value), 
                parseFloat(directionalLightZSlider.value)
            );
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096; 
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 100; 
            directionalLight.shadow.camera.left = -30; 
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;
            directionalLight.shadow.bias = -0.0001; 
            scene.add(directionalLight);
            // Optional: Add a target for the directional light if you want it to point elsewhere than origin
            // const directionalLightTarget = new THREE.Object3D();
            // scene.add(directionalLightTarget);
            // directionalLight.target = directionalLightTarget;
            // directionalLightTarget.position.set(0,0,0); // Example target
            
            fillLight = new THREE.DirectionalLight(0xffffff, parseFloat(fillIntensitySlider.value));
            fillLight.position.set(-15, 10, -20); // Fixed position for fill light
            scene.add(fillLight);

            hemisphereLight = new THREE.HemisphereLight(0x606080, 0x404040, parseFloat(hemisphereIntensitySlider.value)); 
            hemisphereLight.position.set(0, 20, 0);
            scene.add(hemisphereLight);


            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = true; 
            controls.minDistance = 1;
            controls.maxDistance = 150; 
            controls.maxPolarAngle = Math.PI; 
            controls.target.set(0, 0, 0); 
            controls.update();
            
            controls.addEventListener('start', handleInteractionStart);
            controls.addEventListener('end', handleInteractionEnd);
            
            window.addEventListener('resize', onWindowResize, false);
            onWindowResize(); 
        }

        function onWindowResize() {
            if (canvasContainer && canvasContainer.clientWidth > 0 && canvasContainer.clientHeight > 0) {
                const newWidth = canvasContainer.clientWidth;
                const newHeight = canvasContainer.clientHeight;
                camera.aspect = newWidth / newHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(newWidth, newHeight);
            }
        }
        
        function addUniqueVertex(vertex, allVertices, vertexMap, generatedVerticesList) {
            const key = `${vertex.x.toFixed(5)},${vertex.y.toFixed(5)},${vertex.z.toFixed(5)}`;
            if (vertexMap.has(key)) {
                return vertexMap.get(key);
            }
            const newIndex = generatedVerticesList.length; 
            allVertices.push(vertex.x, vertex.y, vertex.z); 
            generatedVerticesList.push(vertex.clone()); 
            vertexMap.set(key, newIndex);
            return newIndex;
        }

        // --- Sierpinski Tetrahedron ---
        function subdivideTetrahedron(v1, v2, v3, v4, level, allVertices, allIndices, vertexMap, generatedVerticesList, generatedFacesList) {
            if (level === 0) {
                const idx1 = addUniqueVertex(v1, allVertices, vertexMap, generatedVerticesList);
                const idx2 = addUniqueVertex(v2, allVertices, vertexMap, generatedVerticesList);
                const idx3 = addUniqueVertex(v3, allVertices, vertexMap, generatedVerticesList);
                const idx4 = addUniqueVertex(v4, allVertices, vertexMap, generatedVerticesList);

                allIndices.push(idx1, idx2, idx3); generatedFacesList.push({ v1: idx1, v2: idx2, v3: idx3 });
                allIndices.push(idx1, idx4, idx2); generatedFacesList.push({ v1: idx1, v2: idx4, v3: idx2 });
                allIndices.push(idx2, idx4, idx3); generatedFacesList.push({ v1: idx2, v2: idx4, v3: idx3 });
                allIndices.push(idx1, idx3, idx4); generatedFacesList.push({ v1: idx1, v2: idx3, v3: idx4 });
                return;
            }

            const m12 = v1.clone().add(v2).multiplyScalar(0.5);
            const m13 = v1.clone().add(v3).multiplyScalar(0.5);
            const m14 = v1.clone().add(v4).multiplyScalar(0.5);
            const m23 = v2.clone().add(v3).multiplyScalar(0.5);
            const m24 = v2.clone().add(v4).multiplyScalar(0.5);
            const m34 = v3.clone().add(v4).multiplyScalar(0.5);

            subdivideTetrahedron(v1,  m12, m13, m14, level - 1, allVertices, allIndices, vertexMap, generatedVerticesList, generatedFacesList);
            subdivideTetrahedron(m12, v2,  m23, m24, level - 1, allVertices, allIndices, vertexMap, generatedVerticesList, generatedFacesList);
            subdivideTetrahedron(m13, m23, v3,  m34, level - 1, allVertices, allIndices, vertexMap, generatedVerticesList, generatedFacesList);
            subdivideTetrahedron(m14, m24, m34, v4,  level - 1, allVertices, allIndices, vertexMap, generatedVerticesList, generatedFacesList);
        }

        // --- Menger Sponge (Cube) ---
        function subdivideCube(center, sideLength, level, allVertices, allIndices, vertexMap, generatedVerticesList, generatedFacesList) {
            if (level === 0) {
                const halfSide = sideLength / 2;
                const vertices = [
                    new THREE.Vector3(center.x - halfSide, center.y - halfSide, center.z + halfSide), // 0
                    new THREE.Vector3(center.x + halfSide, center.y - halfSide, center.z + halfSide), // 1
                    new THREE.Vector3(center.x + halfSide, center.y + halfSide, center.z + halfSide), // 2
                    new THREE.Vector3(center.x - halfSide, center.y + halfSide, center.z + halfSide), // 3
                    new THREE.Vector3(center.x - halfSide, center.y - halfSide, center.z - halfSide), // 4
                    new THREE.Vector3(center.x + halfSide, center.y - halfSide, center.z - halfSide), // 5
                    new THREE.Vector3(center.x + halfSide, center.y + halfSide, center.z - halfSide), // 6
                    new THREE.Vector3(center.x - halfSide, center.y + halfSide, center.z - halfSide)  // 7
                ];
                const idx = vertices.map(v => addUniqueVertex(v, allVertices, vertexMap, generatedVerticesList));

                allIndices.push(idx[0], idx[1], idx[2]); generatedFacesList.push({ v1: idx[0], v2: idx[1], v3: idx[2] });
                allIndices.push(idx[0], idx[2], idx[3]); generatedFacesList.push({ v1: idx[0], v2: idx[2], v3: idx[3] });
                allIndices.push(idx[4], idx[7], idx[6]); generatedFacesList.push({ v1: idx[4], v2: idx[7], v3: idx[6] });
                allIndices.push(idx[4], idx[6], idx[5]); generatedFacesList.push({ v1: idx[4], v2: idx[6], v3: idx[5] });
                allIndices.push(idx[3], idx[2], idx[6]); generatedFacesList.push({ v1: idx[3], v2: idx[2], v3: idx[6] });
                allIndices.push(idx[3], idx[6], idx[7]); generatedFacesList.push({ v1: idx[3], v2: idx[6], v3: idx[7] });
                allIndices.push(idx[0], idx[4], idx[5]); generatedFacesList.push({ v1: idx[0], v2: idx[4], v3: idx[5] });
                allIndices.push(idx[0], idx[5], idx[1]); generatedFacesList.push({ v1: idx[0], v2: idx[5], v3: idx[1] });
                allIndices.push(idx[0], idx[3], idx[7]); generatedFacesList.push({ v1: idx[0], v2: idx[3], v3: idx[7] });
                allIndices.push(idx[0], idx[7], idx[4]); generatedFacesList.push({ v1: idx[0], v2: idx[7], v3: idx[4] });
                allIndices.push(idx[1], idx[5], idx[6]); generatedFacesList.push({ v1: idx[1], v2: idx[5], v3: idx[6] });
                allIndices.push(idx[1], idx[6], idx[2]); generatedFacesList.push({ v1: idx[1], v2: idx[6], v3: idx[2] });
                return;
            }

            const newSideLength = sideLength / 3;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    for (let k = -1; k <= 1; k++) {
                        let zeroCount = 0;
                        if (i === 0) zeroCount++;
                        if (j === 0) zeroCount++;
                        if (k === 0) zeroCount++;

                        if (zeroCount < 2) { 
                            const offset = new THREE.Vector3(i * newSideLength, j * newSideLength, k * newSideLength);
                            const newCenter = center.clone().add(offset);
                            subdivideCube(newCenter, newSideLength, level - 1, allVertices, allIndices, vertexMap, generatedVerticesList, generatedFacesList);
                        }
                    }
                }
            }
        }

        // --- Sierpinski Octahedron ---
        function subdivideOctahedron(center, scale, level, allVertices, allIndices, vertexMap, generatedVerticesList, generatedFacesList) {
            if (level === 0) {
                const vertices = [
                    new THREE.Vector3(center.x, center.y + scale, center.z),         // 0: top
                    new THREE.Vector3(center.x, center.y - scale, center.z),         // 1: bottom
                    new THREE.Vector3(center.x + scale, center.y, center.z),         // 2: +x
                    new THREE.Vector3(center.x - scale, center.y, center.z),         // 3: -x
                    new THREE.Vector3(center.x, center.y, center.z + scale),         // 4: +z
                    new THREE.Vector3(center.x, center.y, center.z - scale)          // 5: -z
                ];
                const idx = vertices.map(v => addUniqueVertex(v, allVertices, vertexMap, generatedVerticesList));

                allIndices.push(idx[0], idx[4], idx[2]); generatedFacesList.push({ v1: idx[0], v2: idx[4], v3: idx[2] }); 
                allIndices.push(idx[0], idx[2], idx[5]); generatedFacesList.push({ v1: idx[0], v2: idx[2], v3: idx[5] }); 
                allIndices.push(idx[0], idx[5], idx[3]); generatedFacesList.push({ v1: idx[0], v2: idx[5], v3: idx[3] }); 
                allIndices.push(idx[0], idx[3], idx[4]); generatedFacesList.push({ v1: idx[0], v2: idx[3], v3: idx[4] }); 
                
                allIndices.push(idx[1], idx[2], idx[4]); generatedFacesList.push({ v1: idx[1], v2: idx[2], v3: idx[4] }); 
                allIndices.push(idx[1], idx[5], idx[2]); generatedFacesList.push({ v1: idx[1], v2: idx[5], v3: idx[2] }); 
                allIndices.push(idx[1], idx[3], idx[5]); generatedFacesList.push({ v1: idx[1], v2: idx[3], v3: idx[5] }); 
                allIndices.push(idx[1], idx[4], idx[3]); generatedFacesList.push({ v1: idx[1], v2: idx[4], v3: idx[3] }); 
                return;
            }

            const newScale = scale * 0.5;
            const parentVerticesForCenters = [ 
                new THREE.Vector3(center.x, center.y + scale, center.z),
                new THREE.Vector3(center.x, center.y - scale, center.z),
                new THREE.Vector3(center.x + scale, center.y, center.z),
                new THREE.Vector3(center.x - scale, center.y, center.z),
                new THREE.Vector3(center.x, center.y, center.z + scale),
                new THREE.Vector3(center.x, center.y, center.z - scale)
            ];

            for (let i = 0; i < parentVerticesForCenters.length; i++) {
                const pv = parentVerticesForCenters[i];
                const newCenter = center.clone().add(pv.clone().sub(center).multiplyScalar(0.5));
                subdivideOctahedron(newCenter, newScale, level - 1, allVertices, allIndices, vertexMap, generatedVerticesList, generatedFacesList);
            }
        }
        
        async function generateFractal() {
            handleInteractionEnd(); 

            if (loadingIndicator.style.display !== 'flex') {
                 loadingIndicator.style.display = 'flex';
            }
            generateButton.disabled = true;
            exportObjButton.disabled = true;

            await new Promise(resolve => setTimeout(resolve, 50)); // Allow UI to update

            if (fractalMesh) {
                scene.remove(fractalMesh);
                if (fractalMesh.geometry) fractalMesh.geometry.dispose();
                if (fractalMesh.material) fractalMesh.material.dispose();
                fractalMesh = null;
            }

            const fractalType = fractalTypeSelector.value;
            const level = parseInt(levelSlider.value);
            const size = parseFloat(sizeSlider.value);
            const color = new THREE.Color(colorPicker.value);

            const allVertices = []; 
            const allIndices = [];  
            const vertexMap = new Map(); 

            generatedVertices = []; 
            generatedFaces = [];    
            
            try {
                if (fractalType === "sierpinskiTetrahedron") {
                    const s = size; 
                    const v1 = new THREE.Vector3(s, s, s);
                    const v2 = new THREE.Vector3(s, -s, -s);
                    const v3 = new THREE.Vector3(-s, s, -s);
                    const v4 = new THREE.Vector3(-s, -s, s);
                    subdivideTetrahedron(v1, v2, v3, v4, level, allVertices, allIndices, vertexMap, generatedVertices, generatedFaces);
                } else if (fractalType === "mengerSponge") {
                    const initialCenter = new THREE.Vector3(0,0,0);
                    subdivideCube(initialCenter, size, level, allVertices, allIndices, vertexMap, generatedVertices, generatedFaces);
                } else if (fractalType === "sierpinskiOctahedron") {
                    const initialCenter = new THREE.Vector3(0,0,0);
                    subdivideOctahedron(initialCenter, size, level, allVertices, allIndices, vertexMap, generatedVertices, generatedFaces);
                }


                if (allVertices.length === 0 && level > 0 && (fractalType !== "mengerSponge" || level > 0) ) {
                     showMessage("生成されたジオメトリがありません。レベルや設定を確認してください。");
                } else if (allVertices.length > 0) {
                    const geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(allVertices, 3));
                    geometry.setIndex(allIndices);
                    geometry.computeVertexNormals(); 

                    const material = new THREE.MeshStandardMaterial({ 
                        color: color,
                        metalness: 0.15, 
                        roughness: 0.8, 
                        flatShading: false, 
                        side: (fractalType === "mengerSponge" || fractalType === "sierpinskiOctahedron") ? THREE.DoubleSide : THREE.FrontSide
                    });
                    
                    fractalMesh = new THREE.Mesh(geometry, material);
                    fractalMesh.castShadow = true;
                    fractalMesh.receiveShadow = true; 
                    scene.add(fractalMesh);
                }
                
            } catch (error) {
                console.error("フラクタル生成中にエラーが発生しました:", error);
                showMessage(`エラーが発生しました: ${error.message}. コンソールで詳細を確認してください。`);
                console.error(error.stack);
            } finally {
                loadingIndicator.style.display = 'none';
                generateButton.disabled = false;
                if (generatedVertices.length > 0 && generatedFaces.length > 0) {
                     exportObjButton.disabled = false;
                } else {
                     exportObjButton.disabled = true; 
                }
                if (!isContinuousAutoRotateOn) {
                    resetInactivityTimer();
                }
            }
        }
        
        function exportToObj() {
            if (!generatedVertices.length || !generatedFaces.length) {
                showMessage("エクスポートするデータがありません。");
                return;
            }
            handleInteractionEnd(); 

            const fractalType = fractalTypeSelector.value;
            let objContent = `# ${fractalType}\n`;
            objContent += `# Generated by 3D Fractal Generator\n`;
            objContent += `# Level: ${levelSlider.value}, Size: ${sizeSlider.value}\n`;
            objContent += "# Vertices: " + generatedVertices.length + "\n";
            objContent += "# Faces: " + generatedFaces.length + "\n\n";

            for (let i = 0; i < generatedVertices.length; i++) {
                const v = generatedVertices[i];
                objContent += `v ${v.x.toFixed(6)} ${v.y.toFixed(6)} ${v.z.toFixed(6)}\n`;
            }
            objContent += "\n";
            for (let i = 0; i < generatedFaces.length; i++) {
                const face = generatedFaces[i];
                objContent += `f ${face.v1 + 1} ${face.v2 + 1} ${face.v3 + 1}\n`; 
            }

            const blob = new Blob([objContent], { type: 'text/plain;charset=utf-8' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `${fractalType}_level${levelSlider.value}_size${parseFloat(sizeSlider.value).toFixed(1)}.obj`;
            document.body.appendChild(link); 
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
            showMessage("OBJファイルがエクスポートされました。");
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Only call controls.update() if the user is not interacting OR if damping is enabled and interaction just ended.
            // OrbitControls handles its own update logic internally when damping is enabled.
            // If we always call it, it might interfere with damping or feel sluggish.
            // The original code had: if (!isUserInteracting) { controls.update(); }
            // This is generally fine with damping.
            controls.update();


            if (fractalMesh) {
                if (isContinuousAutoRotateOn) { 
                    fractalMesh.rotation.y += AUTO_ROTATE_SPEED;
                    fractalMesh.rotation.x += AUTO_ROTATE_SPEED * 0.3; 
                    fractalMesh.rotation.z += AUTO_ROTATE_SPEED * 0.15; 
                } else if (isAutoRotatingByInactivity && !isUserInteracting) { 
                    fractalMesh.rotation.y += AUTO_ROTATE_SPEED;
                    fractalMesh.rotation.x += AUTO_ROTATE_SPEED * 0.3;
                    fractalMesh.rotation.z += AUTO_ROTATE_SPEED * 0.15;
                }
            }
            renderer.render(scene, camera);
        }
        
        const generateFractalDebounced = debounce(generateFractal, 500); 

        // Event Listeners for Fractal Parameters
        fractalTypeSelector.addEventListener('change', () => {
            const selectedType = fractalTypeSelector.value;
            let currentLevel = parseInt(levelSlider.value);
            if (selectedType === 'mengerSponge') {
                levelSlider.max = "4"; 
                if (currentLevel > 4) levelSlider.value = "2"; else if (currentLevel < 0) levelSlider.value = "0";
            } else if (selectedType === 'sierpinskiOctahedron') {
                levelSlider.max = "5"; 
                if (currentLevel > 5) levelSlider.value = "3";
            } else { // sierpinskiTetrahedron
                levelSlider.max = "10"; 
                 if (currentLevel > 10) levelSlider.value = "3";
            }
            levelValueDisplay.textContent = levelSlider.value;
            generateFractalDebounced();
        });

        levelSlider.addEventListener('input', (e) => {
            levelValueDisplay.textContent = e.target.value;
            if (fractalTypeSelector.value === 'mengerSponge' && parseInt(e.target.value) < 0) { 
                levelSlider.value = "0";
                levelValueDisplay.textContent = "0";
            }
            generateFractalDebounced(); 
        });
        sizeSlider.addEventListener('input', (e) => {
            sizeValueDisplay.textContent = parseFloat(e.target.value).toFixed(1);
            generateFractalDebounced(); 
        });
        colorPicker.addEventListener('input', () => { 
            // No need to debounce color picker if it only updates material color
            // However, current setup regenerates fractal, so keep debounce for consistency
            generateFractalDebounced(); 
        });

        generateButton.addEventListener('click', () => {
            if (fractalTypeSelector.value === 'mengerSponge' && parseInt(levelSlider.value) < 0) { 
                levelSlider.value = "0";
                levelValueDisplay.textContent = "0";
            }
            generateFractal(); 
        });
        exportObjButton.addEventListener('click', exportToObj);

        // Event Listeners for UI Toggles
        toggleControlsButton.addEventListener('click', () => {
            controlsPanel.classList.toggle('hidden');
            iconOpenPanel.classList.toggle('hidden'); 
            iconClosePanel.classList.toggle('hidden'); 
            handleInteractionEnd(); 
            requestAnimationFrame(() => { 
                onWindowResize(); // Adjust canvas size after panel toggle
            });
        });

        autoRotateToggleButton.addEventListener('click', () => {
            isContinuousAutoRotateOn = !isContinuousAutoRotateOn;
            iconRotateOn.classList.toggle('hidden'); 
            iconRotateOff.classList.toggle('hidden'); 

            if (isContinuousAutoRotateOn) {
                isAutoRotatingByInactivity = false; 
                clearTimeout(inactivityTimeoutId); 
            } else {
                handleInteractionEnd(); // This will reset inactivity timer if needed
            }
        });

        // Event Listeners for Lighting Controls
        ambientIntensitySlider.addEventListener('input', (e) => {
            const intensity = parseFloat(e.target.value);
            ambientIntensityValue.textContent = intensity.toFixed(1);
            if (ambientLight) ambientLight.intensity = intensity;
        });
        directionalIntensitySlider.addEventListener('input', (e) => {
            const intensity = parseFloat(e.target.value);
            directionalIntensityValue.textContent = intensity.toFixed(1);
            if (directionalLight) directionalLight.intensity = intensity;
        });
        directionalLightXSlider.addEventListener('input', (e) => {
            const posX = parseFloat(e.target.value);
            directionalLightXValue.textContent = posX;
            if (directionalLight) directionalLight.position.x = posX;
        });
        directionalLightYSlider.addEventListener('input', (e) => {
            const posY = parseFloat(e.target.value);
            directionalLightYValue.textContent = posY;
            if (directionalLight) directionalLight.position.y = posY;
        });
        directionalLightZSlider.addEventListener('input', (e) => {
            const posZ = parseFloat(e.target.value);
            directionalLightZValue.textContent = posZ;
            if (directionalLight) directionalLight.position.z = posZ;
        });
        fillIntensitySlider.addEventListener('input', (e) => {
            const intensity = parseFloat(e.target.value);
            fillIntensityValue.textContent = intensity.toFixed(1);
            if (fillLight) fillLight.intensity = intensity;
        });
        hemisphereIntensitySlider.addEventListener('input', (e) => {
            const intensity = parseFloat(e.target.value);
            hemisphereIntensityValue.textContent = intensity.toFixed(1);
            if (hemisphereLight) hemisphereLight.intensity = intensity;
        });


        // Initialization
        initThreeJS(); // Initializes scene, camera, renderer, controls, and LIGHTS
        
        // Set initial state for UI elements based on defaults
        if (isContinuousAutoRotateOn) {
            iconRotateOn.classList.add('hidden');
            iconRotateOff.classList.remove('hidden');
        } else {
            iconRotateOn.classList.remove('hidden');
            iconRotateOff.classList.add('hidden');
        }
        // Ensure level slider max is correctly set based on initial fractal type
        const initialFractalType = fractalTypeSelector.value;
        if (initialFractalType === 'mengerSponge') {
            levelSlider.max = "4";
            if (parseInt(levelSlider.value) < 0) levelSlider.value = "0";
        } else if (initialFractalType === 'sierpinskiOctahedron') {
            levelSlider.max = "5";
        } else {
            levelSlider.max = "10";
        }
        levelValueDisplay.textContent = levelSlider.value; // Update display for level
        sizeValueDisplay.textContent = parseFloat(sizeSlider.value).toFixed(1); // Update display for size


        generateFractal(); // Generate initial fractal
        animate(); // Start animation loop
        
        if (!isContinuousAutoRotateOn) { // Start inactivity timer if not continuous auto-rotate
            resetInactivityTimer();
        }

    </script></body>
</html>
